package com.glide.api.sdk;

import java.util.Arrays;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Map;

import com.glide.api.sdk.client.*;
import com.glide.api.sdk.exceptions.ApiException;
import com.glide.api.sdk.models.requests.JwtOauth;
import com.glide.api.sdk.models.requests.RequestModel;
import com.glide.api.sdk.models.responses.EmptyResponse;
import com.glide.api.sdk.models.responses.JwtOauthAccessToken;
import com.glide.api.sdk.models.responses.ResponseModel;
import com.glide.api.sdk.resources.*;
import com.glide.api.sdk.security.KeySet;
import com.glide.api.sdk.utils.Utils;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.Setter;

public class GlideApiClient implements IGlideApiClient {
    private String clientKey;
    private OAuthJwtGenerator oAuthJwtGenerator;
    private Options options;
    private HttpClient httpClient;
    // DO NOT remove these comments since they serve as anchors for code autogeneration
    /* Autogenerated-root-resource-defs begins */
    @Getter @Setter
    private ITransactionsResource transactions;
    @Getter @Setter
    private IUsersResource users;
    /* Autogenerated-root-resource-defs ends */
    private Impersonating impersonating;
    private final String contentType = "application/json";
    private final int jwtExpirationTime = 60;

    private static String getDefaultStringValue(String val, String defaultValue) {
        return val != null && val != "" ? val : defaultValue;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class Options {
        private String protocol;
        private String host;
        private String URL;
        private String basePath;
        private String audience;

        public Options coalesce(Options options) {
            if (options == null) {
                return this;
            }

            return new Options(
                getDefaultStringValue(options.getProtocol(), this.protocol),
                getDefaultStringValue(options.getHost(), this.host),
                getDefaultStringValue(options.getURL(), this.URL),
                getDefaultStringValue(options.getBasePath(), this.basePath),
                getDefaultStringValue(options.getAudience(), this.audience)
            );
        }

        public String getAudience() {
            return this.audience != "" ? this.audience : this.getHost();
        }

        public String getURL() {
            return this.URL != "" ? this.URL : this.getHost();
        }
    }

    @Data
    @AllArgsConstructor
    private static class Impersonating {
        private String sub;
        private String[] scopes;
        private String accessToken;
        private Calendar accessTokenExpires;

        public String[] getScopes() {
            return scopes != null ? scopes : new String[0];
        }

        public boolean hasScope(String scope) {
            if (scope == null) {
                return false;
            }

            return Arrays.stream(getScopes()).anyMatch(s -> s == scope);
        }

        private long timeToExpire() {
            return Calendar.getInstance().toInstant().getEpochSecond() - accessTokenExpires.toInstant().getEpochSecond();
        }

        public boolean isTokenExpired() {
            return timeToExpire() >= 0;
        }

        public boolean isTokenAboutToExpire() {
            return !isTokenExpired() && -timeToExpire() < (15 * 60);
        }
    }

    @Data
    @AllArgsConstructor
    private static class ImperonsationResponse implements IImperonsationResponse {
        private boolean ok;
        private String[] missingScopes;
        private String requestScopesUrl;

        public static ImperonsationResponse ok() {
            return new ImperonsationResponse(true, null, null);
        }

        public static ImperonsationResponse missingScopes(String[] missingScopes, String requestScopesUrl) {
            return new ImperonsationResponse(false, missingScopes, requestScopesUrl);
        }
    }

    @AllArgsConstructor
    private class AccessTokenWrapper {
        private JwtOauthAccessToken accessToken;

        public String getAccessTokenValue() {
            return accessToken.getAccessToken();
        }

        public boolean hasAccessToken() {
            return getAccessTokenValue() != null && getAccessTokenValue() != "";
        }

        public Calendar getAccessTokenExpires() {
            Calendar accessTokenExpires = Calendar.getInstance();
            accessTokenExpires.add(Calendar.SECOND, accessToken.getExpiresIn());
            return accessTokenExpires;
        }

        public String[] getMissingScopes() {
            return accessToken.getMissingScopes();
        }

        public String getRequestScopesUrl() {
            return accessToken.getRequestScopesUrl();
        }
    }

    public GlideApiClient(@NonNull String clientKey, @NonNull KeySet keySet, Options options) {
        this.clientKey = clientKey;
        this.oAuthJwtGenerator = new OAuthJwtGenerator(keySet);
        initOptions(options);
        this.httpClient = new HttpClient();
        initResources();
    }

    public GlideApiClient(@NonNull String clientKey, @NonNull KeySet keySet) {
        this(clientKey, keySet, null);
    }

    private void initOptions(Options options) {
        Options defaultOtions = new Options(
            "https",
            "api.glide.com",
            "",
            "/",
            ""
        );
        this.options = defaultOtions.coalesce(options);
    }

    private void initResources() {
        // DO NOT remove these comments since they serve as anchors for code autogeneration
        /* Autogenerated-root-resource-init begins */
        this.setTransactions(new TransactionsResource(this));
        this.setUsers(new UsersResource(this));
        /* Autogenerated-root-resource-init ends */
    }

    private String baseURL() {
        String basePath = options.basePath;
        if (!basePath.startsWith("/")) {
            basePath = "/" + basePath;
        }
        if (!basePath.endsWith("/")) {
            basePath += "/";
        }
        return options.protocol.toLowerCase() + "://" + options.getURL().toLowerCase() + basePath.toLowerCase();
    }

    private String getURL(String path) {
        if (path.startsWith("/")) {
            path = path.substring(1);
        }
        return baseURL() + path;
    }

    private HttpClient.Headers getHeaders() {
        Map<String, String> headers = new HashMap<String, String>();
        if (isImpersonating()) {
            headers.put("Authorization", String.format("Bearer %s", impersonating.getAccessToken()));
        }
        headers.put("Host", options.getHost()); // TODO fix: HttpURLConnection is ignoring Host header
        return HttpClient.Headers.make(headers);
    }

    private ResponseModel request(boolean authRequired, Class<? extends ResponseModel> modelCls, String path, String requestMethod, HttpClient.QueryParams qParams, RequestModel payload) throws ApiException {
        if (authRequired && isImpersonating()) {
            refreshAccessToken();
        }

        String stringPayload = payload != null ? payload.getSerialized() : null;
        HttpClient.Response response = httpClient.request(this.getURL(path), requestMethod, getHeaders(), qParams, stringPayload, contentType);
        if (response.isOk()) {
            String responseBody = response.getBody();
            if (responseBody != null && responseBody != "") {
                return Utils.getGson().fromJson(response.getBody(), modelCls);
            }

            return new EmptyResponse();
        }
        ApiException.throwException(response.getError(), response.getStatusCode(), response.getBody(), response.getHeaders());
        return null;
    }

    private ResponseModel request(boolean authRequired, Class<? extends ResponseModel> modelCls, String path, String requestMethod, HttpClient.QueryParams qParams) throws ApiException {
        return request(authRequired, modelCls, path, requestMethod, qParams, null);
    }

    public ResponseModel get(boolean authRequired, Class<? extends ResponseModel> modelCls, String path, HttpClient.QueryParams qParams) throws ApiException {
        return request(authRequired, modelCls, path, "GET", qParams);
    }

    public ResponseModel get(boolean authRequired, Class<? extends ResponseModel> modelCls, String path) throws ApiException {
        return get(authRequired, modelCls, path, null);
    }

    public ResponseModel getWithAuth(Class<? extends ResponseModel> modelCls, String path, HttpClient.QueryParams qParams) throws ApiException {
        return get(true, modelCls, path, qParams);
    }

    public ResponseModel getWithAuth(Class<? extends ResponseModel> modelCls, String path) throws ApiException {
        return getWithAuth(modelCls, path, null);
    }

    public ResponseModel post(boolean authRequired, Class<? extends ResponseModel> modelCls, String path, HttpClient.QueryParams qParams, RequestModel payload) throws ApiException {
        return request(authRequired, modelCls, path, "POST", qParams, payload);
    }

    public ResponseModel post(boolean authRequired, Class<? extends ResponseModel> modelCls, String path, RequestModel payload) throws ApiException {
        return request(authRequired, modelCls, path, "POST", null, payload);
    }

    public ResponseModel post(boolean authRequired, Class<? extends ResponseModel> modelCls, String path, HttpClient.QueryParams qParams) throws ApiException {
        return request(authRequired, modelCls, path, "POST", qParams, null);
    }

    public ResponseModel postWithAuth(Class<? extends ResponseModel> modelCls, String path, HttpClient.QueryParams qParams, RequestModel payload) throws ApiException {
        return post(true, modelCls, path, qParams, payload);
    }

    public ResponseModel postWithNoAuth(Class<? extends ResponseModel> modelCls, String path, HttpClient.QueryParams qParams, RequestModel payload) throws ApiException {
        return post(false, modelCls, path, qParams, payload);
    }

    public ResponseModel postWithAuth(Class<? extends ResponseModel> modelCls, String path, RequestModel payload) throws ApiException {
        return postWithAuth(modelCls, path, null, payload);
    }

    public ResponseModel postWithNoAuth(Class<? extends ResponseModel> modelCls, String path, RequestModel payload) throws ApiException {
        return postWithNoAuth(modelCls, path, null, payload);
    }

    private String getJwt(@NonNull String sub, String[] scopes) {
        return oAuthJwtGenerator.getToken(
            clientKey,
            sub,
            options.getAudience(),
            scopes,
            jwtExpirationTime
        );
    }

    private AccessTokenWrapper getAccessToken(@NonNull String sub, String[] scopes) throws ApiException {
        JwtOauth jwtOauth = new JwtOauth(this.getJwt(sub, scopes));
        JwtOauthAccessToken accessToken = (JwtOauthAccessToken)postWithNoAuth(JwtOauthAccessToken.class, "/oauth/token", jwtOauth);
        return new AccessTokenWrapper(accessToken);
    }

    public ImperonsationResponse startImpersonating(@NonNull String sub, String[] scopes) throws ApiException {
        if (isImpersonating()) {
            if (impersonating.getSub() == sub && (scopes == null || Arrays.stream(scopes).allMatch(scope -> impersonating.hasScope(scope)))) {
                refreshAccessToken();
                return ImperonsationResponse.ok();
            }
            stopImpersonating();
        }

        AccessTokenWrapper accessToken = getAccessToken(sub, scopes);
        if (accessToken.hasAccessToken()) {
            this.impersonating = new Impersonating(
                sub,
                scopes,
                accessToken.getAccessTokenValue(),
                accessToken.getAccessTokenExpires()
            );
            return ImperonsationResponse.ok();
        }

        return ImperonsationResponse.missingScopes(accessToken.getMissingScopes(), accessToken.getRequestScopesUrl());
    }

    private void doRefreshAccessToken(boolean failSilently) throws ApiException {
        try {
            AccessTokenWrapper accessToken = getAccessToken(impersonating.getSub(), impersonating.getScopes());
            if (accessToken.hasAccessToken()) {
                impersonating.setAccessToken(accessToken.getAccessTokenValue());
                impersonating.setAccessTokenExpires(accessToken.getAccessTokenExpires());
            } else if (!failSilently) {
                stopImpersonating();
            }
        } catch (ApiException err) {
            if (!failSilently) {
                throw err;
            }
        }
    }

    private void refreshAccessToken() throws ApiException {
        if (isImpersonating()) {
            if (impersonating.isTokenExpired()) {
                doRefreshAccessToken(false);
            } else if (impersonating.isTokenAboutToExpire()) {
                doRefreshAccessToken(true);
            }
        }
    }

    public ImperonsationResponse startImpersonating(@NonNull String sub) throws ApiException {
        return startImpersonating(sub, null);
    }

    public void stopImpersonating() {
        this.impersonating = null;
    }

    public boolean isImpersonating() {
        return impersonating != null;
    }

    public String impersonatingSub() {
        return isImpersonating() ? impersonating.getSub() : null;
    }

    public String[] impersonatingScopes() {
        return isImpersonating() ? impersonating.getScopes() : null;
    }
}
